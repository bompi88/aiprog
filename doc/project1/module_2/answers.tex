%% The report will be no longer than 3 pages and will include the following:
% 1. Verification of the generality of your A* algorithm. Any aspect of A* that 
% is specifically geared toward CSP and GAC should be in subclasses, not the 
% core A* classes.
% 2. Verification of the generality of your A*-GAC algorithm. Any aspect of 
% A*-GAC that is specifically geared toward VC should be in subclasses, not the 
% core code. You will be reusing A*-GAC on other assignments, so the core should
% be easily extendable via subclassing.
% 3. Verification of a clean separation between your Constraint Network (CNET) 
% and the VIs and CIs of the search states, as shown in Figure 4.
% 4. A clear explanation (with small code segments) of: a) the manner in which 
% your system creates code chunks on the fly, or b) the general workings of your 
% hand-built interpreter for executing constraints in a canonical form, or c) 
% your work-around for avoiding both code chunks and a hand-built interpreter.

\section{Central aspects of your A*-GAC program}
\subsection{Generality of the A* and the A*-GAC}
Two classes has to be subclassed to solve new problems; the BestFirstSearch class and the SearchState class. To utilize the power of the GAC, it has to be run on every generated node, even the root node. So in the subclass of BestFirstSearch, the `create\_root\_node' method has to be overidden to run gac.initialize() and gac.domain\_filtering(), as seen in code snippet \ref{code:create_root}.

\lstinputlisting[emph={create_root},label={code:create_root},caption={Generation of root node.}]{module_2/code_snippets/create_root.py}

Futher, the GAC has to be rerun on each generated successor in the overidden method `generate\_all\_successors', before it gets added to the open heap. Only successors which either got solved by the GAC, or did not get one or more of their domains reduced to an empty domain, is considered as a valid child and should be expanded. The `gac.rerun()' returns \(True\) if the successor is still a viable state after the GAC-reduction. If the state is viable, it gets added to the heap.

\lstinputlisting[emph={GAC},label={code:successor_generation},caption={Generation of vertex successor states.}]{module_2/code_snippets/successor_generation.py}

\subsection{CNET, VIs and CIs}
The domains, constraints and variables are only generated once and shared between the different classes. A dictionary in the GAC maps the variables to the constraints, so the constraints can easily be looked up by a variable.

The constraints is generated as runnable expressions, as in this problem: \( v1 \neq v3 \), where \(v1\) and \(v2\) represent the vertices. In previous example, vertex \(v1\) and \(v2\) should not have the same color. The variable instances (CI) is being stored as list of strings in each constraint, as involved variables. These variables are used to retrieve the domains from a dictionary that is initialized at `gac.initialize()'. Each node has its own dictionary with references to variable domains. If a domain is being altered, a copy of this domain is being made and the reference is updated in the corresponding state.

\subsection*{Heuristics}
It's two heuristics at play, one that selects the successors and one that determines which node to get expanded first. For the selection of successors, we simply select the variable that has the smallest domain and create states for all colors in this variables' domain; one assumption for each color.

If the A* has to pop a node from the heap, it looks at the solution domain, which equals the amount of nodes available, and picks the node that has smallest value. This means we have cut off the domain of possible combinations of colored graphs. If we look at an example:

\begin{align*}
	&v1: [0,1,2,3]\\
	&v2: [0,2]\\
	&v3: [2,3,4]
\end{align*}

Here we have \(4 \cdot 2 \cdot 3 = 24\) possible combinations of the given colors, some of the states are not viable though, but it is still a good measure and the nonviable states can - with no loss in performance - be neglected. The catch, though, is that while multiplying a lot of these values, you get a heavily incrementing value, and can give a negative boost on the performance of the solver. To solve this, we chose to take the logarithmic value of the length of the domains and add all those together. As most know, adding values in the logarithmic scale, is equal multiplying the original values. Another property of this heuristic is that when all domain lengths equal 1, the heuristics equals 0.

\subsection{Evaluation procedure of the GAC}
\lstinputlisting[label={code:make_function},caption={Generation of lambda expressions to evaluate the constraints.}]{module_2/code_snippets/make_functions.py}